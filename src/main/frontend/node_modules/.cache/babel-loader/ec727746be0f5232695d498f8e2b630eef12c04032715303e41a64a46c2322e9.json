{"ast":null,"code":"var _jsxFileName = \"D:\\\\Spring 2023\\\\APT\\\\Cloned project\\\\Search-Engine\\\\src\\\\main\\\\frontend\\\\src\\\\Components\\\\paragraphWithBoldWords.jsx\";\nimport \"./Styles/paragraphWithBoldWords.css\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nfunction exactMatch(word, boldWords) {\n  for (let i = 0; i < boldWords.length; i++) {\n    if (word.match(/boldWords[i]/gi).toLowerCase()) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction paragraphWithBoldWords(paragraph, boldWords) {\n  const boldArr = boldWords.split(' ');\n  // Split the paragraph into an array of words and map over it\n  const boldParagraph = paragraph.split(\" \").map(word => {\n    // If the word is included in the boldWords array, wrap it in a b element\n    if (exactMatch(word, boldArr)) {\n      return /*#__PURE__*/_jsxDEV(\"b\", {\n        className: \"bold\",\n        children: [word, \" \"]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 19,\n        columnNumber: 20\n      }, this);\n    }\n    // Otherwise, return the word as a normal text node\n    return word + \" \";\n  });\n\n  // Join the array of words back into a string and render it inside a p element\n  return /*#__PURE__*/_jsxDEV(\"p\", {\n    className: \"boldP\",\n    children: boldParagraph\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 26,\n    columnNumber: 12\n  }, this);\n}\nexport default paragraphWithBoldWords;","map":{"version":3,"names":["jsxDEV","_jsxDEV","exactMatch","word","boldWords","i","length","match","toLowerCase","paragraphWithBoldWords","paragraph","boldArr","split","boldParagraph","map","className","children","fileName","_jsxFileName","lineNumber","columnNumber"],"sources":["D:/Spring 2023/APT/Cloned project/Search-Engine/src/main/frontend/src/Components/paragraphWithBoldWords.jsx"],"sourcesContent":["import \"./Styles/paragraphWithBoldWords.css\"\r\n\r\nfunction exactMatch(word, boldWords) {\r\n    for (let i = 0; i < boldWords.length; i++) {\r\n        if (word.match(/boldWords[i]/gi).toLowerCase()) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\r\n\r\nfunction paragraphWithBoldWords(paragraph, boldWords) {\r\n    \r\n    const boldArr = boldWords.split(' ');\r\n    // Split the paragraph into an array of words and map over it\r\n    const boldParagraph = paragraph.split(\" \").map((word) => {\r\n        // If the word is included in the boldWords array, wrap it in a b element\r\n        if (exactMatch(word, boldArr)) {\r\n            return <b className=\"bold\">{word} </b>;\r\n        }\r\n        // Otherwise, return the word as a normal text node\r\n        return word + \" \";\r\n    });\r\n\r\n    // Join the array of words back into a string and render it inside a p element\r\n    return <p className=\"boldP\">{boldParagraph}</p>;\r\n}\r\n\r\nexport default paragraphWithBoldWords;"],"mappings":";AAAA,OAAO,qCAAqC;AAAA,SAAAA,MAAA,IAAAC,OAAA;AAE5C,SAASC,UAAUA,CAACC,IAAI,EAAEC,SAAS,EAAE;EACjC,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGD,SAAS,CAACE,MAAM,EAAED,CAAC,EAAE,EAAE;IACvC,IAAIF,IAAI,CAACI,KAAK,CAAC,gBAAgB,CAAC,CAACC,WAAW,CAAC,CAAC,EAAE;MAC5C,OAAO,IAAI;IACf;EACJ;EACA,OAAO,KAAK;AAChB;AAEA,SAASC,sBAAsBA,CAACC,SAAS,EAAEN,SAAS,EAAE;EAElD,MAAMO,OAAO,GAAGP,SAAS,CAACQ,KAAK,CAAC,GAAG,CAAC;EACpC;EACA,MAAMC,aAAa,GAAGH,SAAS,CAACE,KAAK,CAAC,GAAG,CAAC,CAACE,GAAG,CAAEX,IAAI,IAAK;IACrD;IACA,IAAID,UAAU,CAACC,IAAI,EAAEQ,OAAO,CAAC,EAAE;MAC3B,oBAAOV,OAAA;QAAGc,SAAS,EAAC,MAAM;QAAAC,QAAA,GAAEb,IAAI,EAAC,GAAC;MAAA;QAAAc,QAAA,EAAAC,YAAA;QAAAC,UAAA;QAAAC,YAAA;MAAA,OAAG,CAAC;IAC1C;IACA;IACA,OAAOjB,IAAI,GAAG,GAAG;EACrB,CAAC,CAAC;;EAEF;EACA,oBAAOF,OAAA;IAAGc,SAAS,EAAC,OAAO;IAAAC,QAAA,EAAEH;EAAa;IAAAI,QAAA,EAAAC,YAAA;IAAAC,UAAA;IAAAC,YAAA;EAAA,OAAI,CAAC;AACnD;AAEA,eAAeX,sBAAsB"},"metadata":{},"sourceType":"module","externalDependencies":[]}